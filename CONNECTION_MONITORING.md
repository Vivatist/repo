# Мониторинг соединения на стороне клиента NovaVPN

## Проблема

Необходим надёжный, ресурсоэффективный механизм обнаружения потери связи на клиенте, который:
- Работает в реальном времени
- Не нарушает маскировку под TLS
- Не создаёт паттернов для DPI-детектирования
- Минимально нагружает CPU и сеть
- Позволяет оперативно информировать пользователя и инициировать переподключение

## Реализованное решение

### Принцип: пассивный мониторинг на основе существующего трафика

Вместо отправки дополнительных probe-пакетов (ping/pong), решение **отслеживает время последнего полученного пакета от сервера** — будь то data-пакет или keepalive. Это полностью пассивный подход:

```
Сервер шлёт keepalive каждые 18-32 сек (рандомизировано)
         ↓
Клиент фиксирует timestamp каждого входящего пакета
         ↓
Локальный монитор проверяет "сколько секунд с последнего пакета"
         ↓
Уведомляет UI при смене статуса
```

### Три уровня здоровья соединения

| Статус | Условие | Описание |
|--------|---------|----------|
| `HealthGood` (Стабильно) | < 35 сек без пакетов | Связь стабильна |
| `HealthDegraded` (Нестабильно) | 35-60 сек без пакетов | Возможна потеря пакетов, нестабильная сеть |
| `HealthLost` (Потеряно) | > 60 сек без пакетов | Связь потеряна, инициируется reconnect |

**Почему 35 секунд для `Degraded`?**
Максимальный серверный keepalive-интервал = 32 секунды (25 + 7). Если за 35 секунд не пришёл ни один пакет (ни data, ни keepalive) — значит что-то не так.

**Почему 60 секунд для `Lost`?**
Это примерно 2 пропущенных keepalive-цикла сервера. С высокой вероятностью говорит о полной потере связи.

### Защита от DPI-детектирования

#### Рандомизация клиентских keepalive
**Было**: фиксированный интервал 15 секунд — легко обнаружить по регулярным пакетам.

**Стало**: интервал **10-20 секунд**, выбираемый криптографически случайным образом (`crypto/rand`) после каждой отправки. Аналогично серверной стороне, где интервал 18-32 секунды.

```go
// Каждый keepalive отправляется через случайный интервал
func randomKeepaliveInterval() time.Duration {
    n, _ := rand.Int(rand.Reader, big.NewInt(11)) // 0-10
    return time.Duration(10+n.Int64()) * time.Second // 10-20 сек
}
```

#### Рандомизация проверок монитора
Внутренний цикл проверки здоровья тоже рандомизирован (3-7 секунд), хотя он полностью локальный и не влияет на сеть.

### Ресурсоэффективность

| Аспект | Затраты |
|--------|---------|
| **Сеть** | 0 дополнительных пакетов (пассивный анализ) |
| **CPU** | 1 atomic store на пакет + 1 проверка каждые 3-7 сек |
| **Память** | ~128 байт (2 atomic + 2 Duration + 2 callback) |
| **Аллокации** | 0 (lock-free atomic операции) |

### Интеграция

#### Фиксация активности (hot path)
При получении **любого** пакета от сервера (data, keepalive) вызывается:
```go
if c.healthMonitor != nil {
    c.healthMonitor.RecordActivity() // atomic store — 1 наносекунда
}
```

#### Уведомление UI
Колбэк `HealthCallback` вызывается **только при смене** статуса здоровья (не при каждой проверке):
```go
// В конструкторе VPN-клиента
onHealth: func(health domainvpn.ConnectionHealth) {
    log.Printf("[VPN] Здоровье соединения: %s", health)
    // Обновить иконку в трее, показать уведомление и т.д.
}
```

#### Автоматический reconnect
При переходе в `HealthLost` монитор инициирует переподключение **раньше**, чем UDP-сокет вернёт ошибку. Это даёт выигрыш в несколько секунд для восстановления связи.

### Жизненный цикл

```
Connect() → создаётся healthMonitor → reset() → запускается monitorLoop
    ↓
Работа: RecordActivity() на каждом пакете, check() каждые 3-7 сек
    ↓
Потеря связи: HealthLost → reconnect() → reset() → новый monitorLoop
    ↓
Disconnect() → закрывается stopCh → monitorLoop завершается
```

## Изменённые файлы

| Файл | Изменение |
|------|-----------|
| `domain/vpn/interfaces.go` | Добавлены `ConnectionHealth`, `HealthCallback` |
| `infrastructure/vpn/health.go` | **Новый** — реализация `connectionMonitor` |
| `infrastructure/vpn/client.go` | Интеграция монитора + рандомизация keepalive |
| `application/vpnservice/service.go` | Передача `HealthCallback` в конструктор |

## Совместимость

- Серверная сторона **не требует изменений** — монитор полностью пассивный
- Протокол **не изменён** — новых типов пакетов нет
- Обратная совместимость — `HealthCallback` может быть `nil`
